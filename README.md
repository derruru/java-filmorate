# java-filmorate
# Техническое задание 1

## Модели данных
Создайте пакет model. Добавьте в него два класса — Film и User. Это классы — модели данных приложения.
- У model.Film должны быть следующие свойства:
1) целочисленный идентификатор — id;
2) название — name;
3) описание — description;
4) дата релиза — releaseDate;
5) продолжительность фильма — duration.
- Свойства model.User:
1) целочисленный идентификатор — id;
2) электронная почта — email;
3) логин пользователя — login;
4) имя для отображения — name;
5) дата рождения — birthday.

## Хранение данных
Сейчас данные можно хранить в памяти приложения — так же, как вы поступили в случае с менеджером задач. Для этого используйте контроллер.
В следующих спринтах мы расскажем, как правильно хранить данные в долговременном хранилище, чтобы они не зависели от перезапуска приложения.

## REST-контроллеры
Создайте два класса-контроллера. FilmController будет обслуживать фильмы, а UserController — пользователей. Убедитесь, что созданные контроллеры соответствуют правилам REST.
Добавьте в классы-контроллеры эндпоинты с подходящим типом запроса для каждого из случаев.
- Для FilmController:
1) добавление фильма;
2) обновление фильма;
3) получение всех фильмов.
- Для UserController:
1) создание пользователя;
2) обновление пользователя;
3) получение списка всех пользователей.
4) Эндпоинты для создания и обновления данных должны также вернуть созданную или изменённую сущность.

## Валидация
Проверьте данные, которые приходят в запросе на добавление нового фильма или пользователя. Эти данные должны соответствовать определённым критериям.
- Для Film:
1) название не может быть пустым;
2) максимальная длина описания — 200 символов;
3) дата релиза — не раньше 28 декабря 1895 года;
4) продолжительность фильма должна быть положительной.
- Для User:
1) электронная почта не может быть пустой и должна содержать символ @;
2) логин не может быть пустым и содержать пробелы;
3) имя для отображения может быть пустым — в таком случае будет использован логин;
4) дата рождения не может быть в будущем.

# Техническое задание 2
## Наводим порядок в репозитории
Начнём с переработки архитектуры. Сейчас вся логика приложения спрятана в контроллерах — изменим это. Вынесите хранение данных о фильмах и пользователях в отдельные классы. Назовём их «хранилищами» (англ. storage) — так будет сразу понятно, что они делают.  
1) Создайте интерфейсы FilmStorage и UserStorage, в которых будут определены методы добавления, удаления и модификации объектов.
2) Создайте классы InMemoryFilmStorage и InMemoryUserStorage, имплементирующие новые интерфейсы, и перенесите туда всю логику хранения, обновления и поиска объектов.
3) Добавьте к InMemoryFilmStorage и InMemoryUserStorage аннотацию @Component, чтобы впоследствии пользоваться внедрением зависимостей и передавать хранилища сервисам.

Пока у приложения нет никакой бизнес-логики, кроме валидации сущностей. Обеспечим возможность пользователям добавлять друг друга в друзья и ставить фильмам лайки.
1) Создайте UserService, который будет отвечать за такие операции с пользователями, как добавление в друзья, удаление из друзей, вывод списка общих друзей. Пока пользователям не надо одобрять заявки в друзья — добавляем сразу. То есть если Лена стала другом Саши, то это значит, что Саша теперь друг Лены.
2) Создайте FilmService, который будет отвечать за операции с фильмами, — добавление и удаление лайка, вывод 10 наиболее популярных фильмов по количеству лайков. Пусть пока каждый пользователь может поставить лайк фильму только один раз.
3) Добавьте к ним аннотацию @Service — тогда к ним можно будет получить доступ из контроллера.

Переделайте код в контроллерах, сервисах и хранилищах под использование внедрения зависимостей.
1) Используйте аннотации @Service, @Component, @Autowired. Внедряйте зависимости через конструкторы классов.
2) Классы-сервисы должны иметь доступ к классам-хранилищам. Убедитесь, что сервисы зависят от интерфейсов классов-хранилищ, а не их реализаций. Таким образом в будущем будет проще добавлять и использовать новые реализации с другим типом хранения данных.
3) Сервисы должны быть внедрены в соответствующие контроллеры.

## REST
Дальше стоит заняться контроллерами и довести API до соответствия REST.
1) С помощью аннотации @PathVariable добавьте возможность получать каждый фильм и данные о пользователях по их уникальному идентификатору: GET .../users/{id}.
2) Добавьте методы, позволяющие пользователям добавлять друг друга в друзья, получать список общих друзей и лайкать фильмы. Проверьте, что все они работают корректно.
3) PUT /users/{id}/friends/{friendId} — добавление в друзья.
4) DELETE /users/{id}/friends/{friendId} — удаление из друзей.
5) GET /users/{id}/friends — возвращаем список пользователей, являющихся его друзьями.
6) GET /users/{id}/friends/common/{otherId} — список друзей, общих с другим пользователем.
7) PUT /films/{id}/like/{userId} — пользователь ставит лайк фильму.
8) DELETE /films/{id}/like/{userId} — пользователь удаляет лайк.
9) GET /films/popular?count={count} — возвращает список из первых count фильмов по количеству лайков. Если значение параметра count не задано, верните первые 10.

Убедитесь, что ваше приложение возвращает корректные HTTP-коды.
1) 400 — если ошибка валидации: ValidationException;
2) 404 — для всех ситуаций, если искомый объект не найден;
3) 500 — если возникло исключение.